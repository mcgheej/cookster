# Plans Data Access

The application's Firestore database contains a collection of plan documents. The collection is named `plans` and the schema used for a plan document is:

```bat
color: string
date: timestamp
description: string
kitchenName: string
kitchenResources: [
  {
    actions: [
      {
        name: string
        timeOffset: number
      }
    ]
    description: string
    index: number
    maxParallelActivities: number
    name: string
  }
]
name: string
```

## Plans Data Model

Several interfaces and classes are used to model plan data.

### PlanBase Interface

This is the base interface for all plan data models.

```ts
export interface PlanBase {
  id: string;
  name: string;
  description: string;
  color: string;
  kitchenName: string;
  kitchenResources: PlanKitchenResource[];
}
```

This contains an _id_ field and all fields from the plan document schema except the _data_ field which is a Firestore specific data type.

### PlanDB Interface

This interface extends the _PlanBase_ interface to include the _date_ field (Firestore Timestamp type).

```ts
export interface planDB extends PlanBase {
  date: Timestamp;
}
```

### PlanSummary Interface

This interface extends the _PlanBase_ interface and adds a Date field, called _dateTime_, which is calculated from plan timestamp field (_date_).

```ts
export interface PlanSummary extends PlanBase {
  dateTime: Date;
}
```

## AfPlansService

This service provides the Firestore layer for the plans collection. Initially I will implement a simple snapshot listener to receive any changes made to the plans collection. The public API to the service will comprise an observable that emits arrays of change objects.

A change object is defined by the interface _PlanChange_.

```ts
interface PlanChange {
  type: 'added' | 'modified' | 'removed';
  planDB: planDB;
}
```

The service is provided at the `root` level and the constructor kicks off the snapshot listener. As changes are handled by the snapshot next callback function the function takes the document data received from Firestore and adds the document id to create a PlanDB object. The private method used to setup the snapshot listener is:

```ts
  private setupSnapshotListener() {
    const plansCollection = collection(this.firestore, 'plans');
    onSnapshot(plansCollection, (snapshot) => {
      const changes: PlanChange[] = [];
      snapshot.docChanges().forEach((change) => {
        changes.push({ type: change.type, planDB: { ...change.doc.data(), id: change.doc.id } as planDB });
      });
      this.plansChangesSubject$.next(changes);
    });
  }
```

## PlansDataService

The PlansDataService is the public facing service used by the application to access plans data. Initially I will implement functionality to emit _PlanSummary_ objects that can be rendered in the plans page.

The _PlansDataService_ is provided at the `root` level and in the constructor a subscription to the _AfPlansService_ _plansChanges$_ observable is set up.

Changes emitted by the _AfPlansService.plansChanges$_ property are processed to update a local cache of Plan Summary objects and these objects are emitted via the PlansDataService.planSummaries$ property, part of the libraries public API.
